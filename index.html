<!DOCTYPE html>
<html>

  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <meta name="description" content="Chess-mates-josh-and-connor- : ">

    <link rel="stylesheet" type="text/css" media="screen" href="stylesheets/stylesheet.css">

    <title>Chess-mates-josh-and-connor-</title>
  </head>

  <body>

    <!-- HEADER -->
    <div id="header_wrap" class="outer">
        <header class="inner">
          <a id="forkme_banner" href="https://github.com/oplS16projects/Chess-Mates-Josh-and-Connor-">View on GitHub</a>

          <h1 id="project_title">Chess-mates-josh-and-connor-</h1>
          <h2 id="project_tagline"></h2>

            <section id="downloads">
              <a class="zip_download_link" href="https://github.com/oplS16projects/Chess-Mates-Josh-and-Connor-/zipball/master">Download this project as a .zip file</a>
              <a class="tar_download_link" href="https://github.com/oplS16projects/Chess-Mates-Josh-and-Connor-/tarball/master">Download this project as a tar.gz file</a>
            </section>
        </header>
    </div>

    <!-- MAIN CONTENT -->
    <div id="main_content_wrap" class="outer">
      <section id="main_content" class="inner">
        <h1>
<a id="fp7-chessnuts" class="anchor" href="#fp7-chessnuts" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>FP7-ChessNuts</h1>

<h2>
<a id="authors" class="anchor" href="#authors" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Authors</h2>

<p>Conor Finegan and Joshua Blanchette</p>

<h2>
<a id="overview" class="anchor" href="#overview" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Overview</h2>

<p>Conor and I have recreated the classic game of Chess.  We as a team have incorporated a stable, high-performing back end and a visually appealing UI.</p>

<h2>
<a id="screenshot" class="anchor" href="#screenshot" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Screenshot</h2>

<p>Here is a screenshot of our chessboard.</p>

<p><img src="https://raw.githubusercontent.com/oplS16projects/Chess-Mates-Josh-and-Connor-/master/Chessboard_Image.png" alt="alt-tag"></p>

<h2>
<a id="concepts-demonstrated" class="anchor" href="#concepts-demonstrated" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Concepts Demonstrated</h2>

<p>Chess is a highly stateful game, therefor our project is very object-oriented.  The pieces, tiles, and board are all seperated into classes.  High-order procedures like map and filter were very helpful when trying to find the valid moves that a piece can make.</p>

<h2>
<a id="external-technology-and-libraries" class="anchor" href="#external-technology-and-libraries" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>External Technology and Libraries</h2>

<p>We imported various sprite images to use for our pieces.  We used two libraries throughout our project, racket/GUI and racket/Draw. Racket/GUI and racket/Draw to create the chessboard and instantiate the window, and racket/draw again to draw the Chess pieces.</p>

<h2>
<a id="favorite-scheme-expressions" class="anchor" href="#favorite-scheme-expressions" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Favorite Scheme Expressions</h2>

<h4>
<a id="josh" class="anchor" href="#josh" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Josh</h4>

<p>The code linked below is my favorite scheme expression.  It's so simple, yet it embodies almost all of the mobility of a pawn.  A pawn can move up two tiles if it has not moved yet.  So the code checks if the Y coordinate is equal to its start-y, and if it is, then it will allow the pawn to move two spaces.  Again, so simple, yet creative. </p>

<div class="highlight highlight-source-scheme"><pre><span class="pl-c">; if y-pos = start-pos, then piece hasn't moved and allow double move</span>
          (<span class="pl-k">if</span> (<span class="pl-k">and</span> (<span class="pl-k">=</span> y start-y)
                   (call (call board <span class="pl-c1">'tile-at</span> x (op y <span class="pl-c1">1</span>)) <span class="pl-c1">'is-empty</span>)
                   (call (call board <span class="pl-c1">'tile-at</span> x (op y <span class="pl-c1">2</span>)) <span class="pl-c1">'is-empty</span>))
              (<span class="pl-k">set!</span> moves (<span class="pl-c1">cons</span> (call board <span class="pl-c1">'tile-at</span> x (op y <span class="pl-c1">2</span>)) moves))
              void)</pre></div>

<h4>
<a id="conor" class="anchor" href="#conor" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Conor</h4>

<p>
  I'm particularly proud of this procedure from `accum-tiles.rkt`, which is a 2-dimensional accumulate procedure that iterates
  over a matrix of tiles, saving valid moves until it reaches an obstical (or the end of the board). This function embodies
  the spirit of functional programming because it's a higher-order procedure that breaks down a complicated problem (accumulating
  moves for rook, bishop, and queen) into a simple solution that can be customized with different parameters.
</p>

<div class="highlight highlight-source-scheme"><pre>;; baseline procedure for accumulating tiles with a given pattern
;; of transforming x and y. Respects line of sight, and makes
;; the distinction between a valid move onto an enemy tile and
;; an invalid move onto a friendly tile
(define (accum-tiles
         x-transform
         y-transform
         board
         start-tile
         team)
  
  (define (iter tile out-lst)
    (cond
      ; if tile is null or same team, return current list
      ((or (eq? tile '())
           (and (not (call tile 'is-empty))
                (eq? team (call (call tile 'get-piece) 'get-team))))
       out-lst)
      
      ; if tile contains enemy piece, return current list + current tile
      ((and (not (call tile 'is-empty))
            (not (eq? team (call (call tile 'get-piece) 'get-team))))
       (cons tile out-lst))
      
      ; otherwise store current tile and make recursive call
      (else
       (let ((x (call tile 'get-x))
             (y (call tile 'get-y)))
         (iter (call board 'tile-at (x-transform x) (y-transform y))
               (cons tile out-lst))))))
  
  ; baseline call to iter, starts with
  ; a transform because the start tile
  ; is not considered to be a valid move
  (let ((x (call start-tile 'get-x))
        (y (call start-tile 'get-y)))
    (iter (call board 'tile-at (x-transform x) (y-transform y))
          '())))
</span></pre></div>

<h1>
<a id="how-to-download-and-run" class="anchor" href="#how-to-download-and-run" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>How to Download and Run</h1>

<p>To open ChessNuts, download the zip file at the top of this page and run src/main.rkt. Use left click to select/move a piece, and right click to cancel a selection.</p>
      </section>
    </div>

    <!-- FOOTER  -->
    <div id="footer_wrap" class="outer">
      <footer class="inner">
        <p class="copyright">Chess-mates-josh-and-connor- maintained by <a href="https://github.com/oplS16projects">oplS16projects</a></p>
        <p>Published with <a href="https://pages.github.com">GitHub Pages</a></p>
      </footer>
    </div>

    

  </body>
</html>
