<!DOCTYPE html>
<html>

  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <meta name="description" content="Chess-mates-josh-and-connor- : ">

    <link rel="stylesheet" type="text/css" media="screen" href="stylesheets/stylesheet.css">

    <title>Chess-mates-josh-and-connor-</title>
  </head>

  <body>

    <!-- HEADER -->
    <div id="header_wrap" class="outer">
        <header class="inner">
          <a id="forkme_banner" href="https://github.com/oplS16projects/Chess-Mates-Josh-and-Connor-">View on GitHub</a>

          <h1 id="project_title">Chess-mates-josh-and-connor-</h1>
          <h2 id="project_tagline"></h2>

            <section id="downloads">
              <a class="zip_download_link" href="https://github.com/oplS16projects/Chess-Mates-Josh-and-Connor-/zipball/master">Download this project as a .zip file</a>
              <a class="tar_download_link" href="https://github.com/oplS16projects/Chess-Mates-Josh-and-Connor-/tarball/master">Download this project as a tar.gz file</a>
            </section>
        </header>
    </div>

    <!-- MAIN CONTENT -->
    <div id="main_content_wrap" class="outer">
      <section id="main_content" class="inner">
        <h1>
<a id="fp7-chessnuts" class="anchor" href="#fp7-chessnuts" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>FP7-ChessNuts</h1>

<h2>
<a id="authors" class="anchor" href="#authors" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Authors</h2>

<p>Conor Finegan and Joshua Blanchette</p>

<h2>
<a id="overview" class="anchor" href="#overview" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Overview</h2>

<p>Conor and I have recreated the classic game of Chess.  We as a team have incorporated a stable, high-performing back end and a visually appealing UI.</p>

<h2>
<a id="screenshot" class="anchor" href="#screenshot" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Screenshot</h2>

<p>Here is a screenshot of our chessboard.</p>

<p><img src="https://github.com/oplS16projects/Chess-Mates-Josh-and-Connor-/blob/master/Chessboard_Image.png" alt="alt-tag"></p>

<h2>
<a id="concepts-demonstrated" class="anchor" href="#concepts-demonstrated" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Concepts Demonstrated</h2>

<p>Chess is a highly stateful game, therefor our project is very object-oriented.  The pieces, tiles, and board are all seperated into classes.  High-order procedures like map and filter were very helpful when trying to find the valid moves that a piece can make.</p>

<h2>
<a id="external-technology-and-libraries" class="anchor" href="#external-technology-and-libraries" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>External Technology and Libraries</h2>

<p>We imported various sprite images to use for our pieces.  We used two libraries throughout our project, racket/GUI and racket/Draw. Racket/GUI and racket/Draw to create the chessboard and instantiate the window, and racket/draw again to draw the Chess pieces.</p>

<h2>
<a id="favorite-scheme-expressions" class="anchor" href="#favorite-scheme-expressions" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Favorite Scheme Expressions</h2>

<h4>
<a id="josh" class="anchor" href="#josh" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Josh</h4>

<p>The code linked below is my favorite scheme expression.  It's so simple, yet it embodies almost all of the mobility of a pawn.  A pawn can move up two tiles if it has not moved yet.  So the code checks if the Y coordinate is equal to its start-y, and if it is, then it will allow the pawn to move two spaces.  Again, so simple, yet creative. </p>

<div class="highlight highlight-source-scheme"><pre><span class="pl-c">; if y-pos = start-pos, then piece hasn't moved and allow double move</span>
          (<span class="pl-k">if</span> (<span class="pl-k">and</span> (<span class="pl-k">=</span> y start-y)
                   (call (call board <span class="pl-c1">'tile-at</span> x (op y <span class="pl-c1">1</span>)) <span class="pl-c1">'is-empty</span>)
                   (call (call board <span class="pl-c1">'tile-at</span> x (op y <span class="pl-c1">2</span>)) <span class="pl-c1">'is-empty</span>))
              (<span class="pl-k">set!</span> moves (<span class="pl-c1">cons</span> (call board <span class="pl-c1">'tile-at</span> x (op y <span class="pl-c1">2</span>)) moves))
              void)</pre></div>

<h4>
<a id="conor" class="anchor" href="#conor" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Conor</h4>

<p>
I'm particularly proud of this procedure I wrote to find valid moves for the rook, bishop, and queen classes.
It takes 2 procedures as parameters to transform over the X and y coordinates of the tile, allowing it to accumulate
tiles in any pattern you can think of. As a higher-order procedure, this code is the embodiment of the functional
programming techniques that we learned this semester. Having written this function made implementing the pathfinding
for rook, bishop, and queen extremely painless and easy compared to how we would have otherwise needed to 
implement those methods.
</p>

<div class="highlight highlight-source-scheme"><pre>(define (accum-tiles
         x-transform
         y-transform
         board
         start-tile
         team)
  
  (define (iter tile out-lst)
    (cond
      ; if tile is null or same team, return current list
      ((or (eq? tile '())
           (and (not (call tile 'is-empty))
                (eq? team (call (call tile 'get-piece) 'get-team))))
       out-lst)
      
      ; if tile contains enemy piece, return current list + current tile
      ((and (not (call tile 'is-empty))
            (not (eq? team (call (call tile 'get-piece) 'get-team))))
       (cons tile out-lst))
      
      ; otherwise store current tile and make recursive call
      (else
       (let ((x (call tile 'get-x))
             (y (call tile 'get-y)))
         (iter (call board 'tile-at (x-transform x) (y-transform y))
               (cons tile out-lst))))))</span></pre></div>

<h1>
<a id="how-to-download-and-run" class="anchor" href="#how-to-download-and-run" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>How to Download and Run</h1>

<p>Simply download the zip file(link at the top of the page), open the chess-main.rkt  file, and run it.  Easy as Sunday morning.</p>
      </section>
    </div>

    <!-- FOOTER  -->
    <div id="footer_wrap" class="outer">
      <footer class="inner">
        <p class="copyright">Chess-mates-josh-and-connor- maintained by <a href="https://github.com/oplS16projects">oplS16projects</a></p>
        <p>Published with <a href="https://pages.github.com">GitHub Pages</a></p>
      </footer>
    </div>

    

  </body>
</html>
